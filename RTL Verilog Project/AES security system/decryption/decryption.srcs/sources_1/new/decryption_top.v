`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// AES Decryption Top Module 
//
// Description:
// This module performs AES decryption using 128-bit input ciphertext and key. It includes:
// - Key and ciphertext 32 bits-by-32 bits loading
// - Key expansion into 11 round keys
// - AES decryption using 10 rounds
// - Pipelining between AES rounds using a register (round_output_reg)
//
// Pipeline Explanation:
// - round_output_reg is the main pipeline register.
// - Each AES decryption round is executed in one cycle, and its output is staged in round_output_reg.
// - Internally, the decryption round includes: InvShiftRows -> InvSubBytes -> AddRoundKey -> InvMixColumns
// - The pipeline register allows clean data separation between rounds and enhances throughput.
//////////////////////////////////////////////////////////////////////////////////

module decryption_top (
    input clk,
    input rst,
    input [31:0] key_in,              // 32-bit of key
    input [31:0] cipher_text_in,      // 32-bit of ciphertext
    output wire [127:0] plain_text,   // 128-bit output plaintext
    output reg done_flag              // Flag indicating decryption is complete
);

    // === Internal Registers ===
    reg [127:0] full_key;             // Assembled 128-bit key from 4x32-bit inputs
    reg [127:0] full_cipher_text;     // Assembled 128-bit ciphertext from 4x32-bit inputs
    reg [2:0] load_counter;           // Counter to track how many 32-bit words loaded
    reg data_ready, key_loaded;       // Flags for signaling loading completion

    // === Round Keys ===
    reg [127:0] round_key_mem [0:10]; // Array to store all 11 round keys
    wire [127:0] generated_round_keys [0:10]; // Wires connected to key expansion module
    wire done;                        // Signal from key expansion module indicating completion

    reg [3:0] key_index;              // Index for writing round keys to memory
    reg pipeline_valid;               // Control signal for writing keys

    // === FSM and Output ===
    reg [3:0] round_counter;          // Tracks which decryption round we are in (10 -> 0)
    reg decrypting;                  // Flag indicating active decryption
    reg [127:0] round_output_reg;     // <<<<<<<< PIPELINE REGISTER >>>>>>>>
                                      // This stores the output of one round before feeding the next
    reg [127:0] plain_text_reg;       // Final plaintext output after round 0

    // === Combinational Round Wires ===
    wire [127:0] shift_out, sub_out, add_out, mix_out;

    // === Key and Ciphertext Loader ===
    // Assembles 128-bit key and ciphertext from 4x32-bit inputs
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            full_key <= 0;
            full_cipher_text <= 0;
            load_counter <= 0;
            data_ready <= 0;
        end else if (load_counter < 4) begin
            case (load_counter)
                0: begin full_key[127:96] <= key_in; full_cipher_text[127:96] <= cipher_text_in; end
                1: begin full_key[95:64]  <= key_in; full_cipher_text[95:64]  <= cipher_text_in; end
                2: begin full_key[63:32]  <= key_in; full_cipher_text[63:32]  <= cipher_text_in; end
                3: begin
                    full_key[31:0] <= key_in;
                    full_cipher_text[31:0] <= cipher_text_in;
                    data_ready <= 1;  // All words loaded
                end
            endcase
            load_counter <= load_counter + 1;
        end
    end

    integer i;
    // === Round Key Storage ===
    // Stores all round keys generated by key expansion
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            key_loaded <= 0;
            key_index <= 0;
            pipeline_valid <= 0;
            for (i = 0; i <= 10; i = i + 1)
                round_key_mem[i] <= 0;
        end else begin
            if (done && !pipeline_valid) begin
                key_index <= 0;
                pipeline_valid <= 1; // Start writing keys
            end
            if (pipeline_valid) begin
                round_key_mem[key_index] <= generated_round_keys[key_index];
                key_index <= key_index + 1;
                if (key_index == 10) begin
                    key_loaded <= 1;       // All keys loaded
                    pipeline_valid <= 0;   // Done writing
                end
            end
        end
    end

    // === Key Expansion Module ===
    // Generates 11 round keys from 128-bit input key
    key_expansion_module key_exp_inst (
        .clk(clk),
        .rst(rst),
        .input_key(full_key),
        .round_key_0(generated_round_keys[0]),
        .round_key_1(generated_round_keys[1]),
        .round_key_2(generated_round_keys[2]),
        .round_key_3(generated_round_keys[3]),
        .round_key_4(generated_round_keys[4]),
        .round_key_5(generated_round_keys[5]),
        .round_key_6(generated_round_keys[6]),
        .round_key_7(generated_round_keys[7]),
        .round_key_8(generated_round_keys[8]),
        .round_key_9(generated_round_keys[9]),
        .round_key_10(generated_round_keys[10]),
        .done(done)
    );

    // === AES Round FSM ===
    // Controls round transitions and uses round_output_reg as a pipeline register
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            round_counter <= 0;
            decrypting <= 0;
            done_flag <= 0;
            round_output_reg <= 0;
            plain_text_reg <= 0;
        end else if (key_loaded && !decrypting) begin
            // Initial AddRoundKey step
            round_output_reg <= full_cipher_text ^ round_key_mem[10];
            round_counter <= 9;
            decrypting <= 1;
        end else if (decrypting) begin
            if (round_counter > 0) begin
                round_output_reg <= mix_out; // Pipeline register assignment
                round_counter <= round_counter - 1;
            end else begin
                plain_text_reg <= add_out; // Final round has no MixColumns
                decrypting <= 0;
                done_flag <= 1;
            end
        end
    end

    // === Decryption Round Logic ===
    // Order: InvShiftRows -> InvSubBytes -> AddRoundKey -> InvMixColumns
    invshiftrow u_shift (.state_in(round_output_reg), .state_out(shift_out));
    invsubbyte u_sub   (.in_data(shift_out), .out(sub_out));
    addroundkey_decrypt u_add (
        .state_in(sub_out),
        .round_key(round_key_mem[round_counter]),
        .state_out(add_out)
    );
    invmixcol u_mix (
        .state_in(add_out),
        .state_out(mix_out)
    );

    // === Final Output Assignment ===
    assign plain_text = plain_text_reg;

endmodule
